#!/bin/bash
# System health check script

echo "=== System Health Report ==="
echo "Date: $(date)"
echo

echo "--- CPU Usage ---"
top -bn1 | grep "Cpu(s)" | awk '{print "CPU Usage: " $2 + $4 "%"}'

echo
echo "--- Memory Usage ---"
free -h | grep Mem | awk '{print "Total: " $2 ", Used: " $3 ", Free: " $4}'

echo
echo "--- Disk Usage ---"
df -h | grep -vE '^Filesystem|tmpfs|cdrom'

echo
echo "--- Top 5 Processes by CPU ---"
ps aux --sort=-%cpu | head -6

echo
echo "--- Network Connections ---"
netstat -an | grep ESTABLISHED | wc -l | awk '{print "Active connections: " $1}'


============================================================

#!/bin/bash
# Docker container cleanup script

echo "Cleaning up Docker resources..."

# Remove stopped containers
echo "Removing stopped containers..."
docker container prune -f

# Remove unused images
echo "Removing dangling images..."
docker image prune -f

# Remove unused volumes
echo "Removing unused volumes..."
docker volume prune -f

# Remove unused networks
echo "Removing unused networks..."
docker network prune -f

echo
echo "Disk space reclaimed:"
docker system df


============================================================

#!/bin/bash
# Advanced log analyzer

LOG_FILE=${1:-"/var/log/syslog"}
OUTPUT_DIR="./log_analysis"

mkdir -p "$OUTPUT_DIR"

echo "Analyzing $LOG_FILE..."

# Error count
echo "--- Error Summary ---" > "$OUTPUT_DIR/errors.txt"
grep -i "error" "$LOG_FILE" | cut -d':' -f4- | sort | uniq -c | sort -rn >> "$OUTPUT_DIR/errors.txt"

# Warning count
echo "--- Warning Summary ---" > "$OUTPUT_DIR/warnings.txt"
grep -i "warning" "$LOG_FILE" | cut -d':' -f4- | sort | uniq -c | sort -rn >> "$OUTPUT_DIR/warnings.txt"

# Timeline
echo "--- Hourly Activity ---" > "$OUTPUT_DIR/timeline.txt"
awk '{print $3}' "$LOG_FILE" | cut -d':' -f1 | sort | uniq -c >> "$OUTPUT_DIR/timeline.txt"

echo "Analysis complete. Results in $OUTPUT_DIR/"


============================================================

#!/bin/bash
# Advanced backup script with rotation

SOURCE_DIR="${1:-/data}"
BACKUP_ROOT="/backup"
RETENTION_DAYS=7
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="$BACKUP_ROOT/$DATE"

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Backup with progress
echo "Starting backup of $SOURCE_DIR..."
tar -czf "$BACKUP_DIR/backup.tar.gz" "$SOURCE_DIR" 2>&1 |     while read line; do
        echo "  $line"
    done

# Calculate checksum
cd "$BACKUP_DIR"
sha256sum backup.tar.gz > backup.tar.gz.sha256

# Remove old backups
echo "Cleaning old backups (older than $RETENTION_DAYS days)..."
find "$BACKUP_ROOT" -maxdepth 1 -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;

# Report
BACKUP_SIZE=$(du -sh "$BACKUP_DIR" | cut -f1)
echo "Backup complete!"
echo "  Location: $BACKUP_DIR"
echo "  Size: $BACKUP_SIZE"
echo "  Checksum: $(cat backup.tar.gz.sha256)"


============================================================

#!/bin/bash
# Batch git repository updater

REPO_DIR="${1:-.}"

echo "Updating all git repositories in $REPO_DIR..."

find "$REPO_DIR" -name ".git" -type d | while read gitdir; do
    repo=$(dirname "$gitdir")
    echo
    echo "=== $(basename "$repo") ==="
    cd "$repo"

    # Check for changes
    if [[ -n $(git status -s) ]]; then
        echo "  ⚠ Uncommitted changes"
        git status -s
    else
        # Pull updates
        echo "  Pulling updates..."
        git pull --rebase

        if [ $? -eq 0 ]; then
            echo "  ✓ Updated successfully"
        else
            echo "  ✗ Update failed"
        fi
    fi
done

echo
echo "All repositories processed"


============================================================

#!/bin/bash
# PostgreSQL database maintenance

DB_NAME="${1:-mydb}"
DB_USER="${2:-postgres}"

echo "=== Database Maintenance: $DB_NAME ==="

# Backup
echo "Creating backup..."
BACKUP_FILE="backup_${DB_NAME}_$(date +%Y%m%d).sql"
pg_dump -U "$DB_USER" "$DB_NAME" > "$BACKUP_FILE"
gzip "$BACKUP_FILE"
echo "  Backup: ${BACKUP_FILE}.gz"

# Vacuum
echo "Running VACUUM..."
psql -U "$DB_USER" -d "$DB_NAME" -c "VACUUM ANALYZE;"

# Reindex
echo "Reindexing..."
psql -U "$DB_USER" -d "$DB_NAME" -c "REINDEX DATABASE $DB_NAME;"

# Statistics
echo
echo "=== Database Statistics ==="
psql -U "$DB_USER" -d "$DB_NAME" -c "    SELECT schemaname, tablename,
           pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
    FROM pg_tables
    WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
    ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
    LIMIT 10;"

echo "Maintenance complete"


============================================================

#!/bin/bash
# Simple website deployment script

REPO_URL="${1}"
DEPLOY_DIR="/var/www/html"
SERVICE_NAME="nginx"

if [ -z "$REPO_URL" ]; then
    echo "Usage: $0 <git-repo-url>"
    exit 1
fi

# Create temp directory
TEMP_DIR=$(mktemp -d)
cd "$TEMP_DIR"

echo "Cloning repository..."
git clone "$REPO_URL" .

# Run tests if available
if [ -f "package.json" ]; then
    echo "Running tests..."
    npm install
    npm test || { echo "Tests failed!"; exit 1; }
fi

# Backup current deployment
if [ -d "$DEPLOY_DIR" ]; then
    echo "Backing up current deployment..."
    tar -czf "/tmp/backup_$(date +%Y%m%d_%H%M%S).tar.gz" "$DEPLOY_DIR"
fi

# Deploy
echo "Deploying..."
rsync -av --delete "$TEMP_DIR/" "$DEPLOY_DIR/"

# Restart service
echo "Restarting $SERVICE_NAME..."
systemctl restart "$SERVICE_NAME"

# Cleanup
cd /
rm -rf "$TEMP_DIR"

echo "Deployment complete!"


============================================================

#!/bin/bash
# Server monitoring with alerts

THRESHOLD_CPU=80
THRESHOLD_MEM=90
THRESHOLD_DISK=85
ALERT_EMAIL="admin@example.com"

send_alert() {
    local subject="$1"
    local message="$2"
    echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
}

# Check CPU
cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1)
if [ $cpu_usage -gt $THRESHOLD_CPU ]; then
    send_alert "High CPU Usage Alert" "CPU usage is ${cpu_usage}%"
fi

# Check Memory
mem_usage=$(free | grep Mem | awk '{print ($3/$2) * 100.0}' | cut -d'.' -f1)
if [ $mem_usage -gt $THRESHOLD_MEM ]; then
    send_alert "High Memory Usage Alert" "Memory usage is ${mem_usage}%"
fi

# Check Disk
disk_usage=$(df -h / | tail -1 | awk '{print $5}' | cut -d'%' -f1)
if [ $disk_usage -gt $THRESHOLD_DISK ]; then
    send_alert "High Disk Usage Alert" "Disk usage is ${disk_usage}%"
fi

echo "Monitoring complete at $(date)"


============================================================

#!/bin/bash
# API endpoint health checker

ENDPOINTS=(
    "https://api.example.com/health"
    "https://api.example.com/status"
    "https://api.example.com/version"
)

TIMEOUT=10
REPORT_FILE="api_health_$(date +%Y%m%d_%H%M%S).txt"

{
    echo "API Health Check Report"
    echo "======================="
    echo "Date: $(date)"
    echo

    for endpoint in "${ENDPOINTS[@]}"; do
        echo "Testing: $endpoint"

        start_time=$(date +%s%N)
        response=$(curl -s -w "HTTP_CODE:%{http_code}" --max-time $TIMEOUT "$endpoint")
        end_time=$(date +%s%N)

        http_code=$(echo "$response" | grep -o "HTTP_CODE:[0-9]*" | cut -d':' -f2)
        response_time=$(( (end_time - start_time) / 1000000 ))

        if [ "$http_code" = "200" ]; then
            echo "  ✓ Status: OK"
        else
            echo "  ✗ Status: Failed (HTTP $http_code)"
        fi

        echo "  Response time: ${response_time}ms"
        echo
    done

    echo "Report complete"
} | tee "$REPORT_FILE"


============================================================

#!/bin/bash
# Simple process manager

PROCESS_NAME=$1
ACTION=$2
PID_FILE="/var/run/${PROCESS_NAME}.pid"

start_process() {
    if [ -f "$PID_FILE" ]; then
        echo "Process already running (PID: $(cat $PID_FILE))"
        return 1
    fi

    echo "Starting $PROCESS_NAME..."
    nohup /usr/bin/$PROCESS_NAME > /dev/null 2>&1 &
    echo $! > "$PID_FILE"
    echo "Started with PID: $(cat $PID_FILE)"
}

stop_process() {
    if [ ! -f "$PID_FILE" ]; then
        echo "Process not running"
        return 1
    fi

    PID=$(cat "$PID_FILE")
    echo "Stopping $PROCESS_NAME (PID: $PID)..."
    kill "$PID"

    # Wait for process to stop
    timeout=10
    while kill -0 "$PID" 2>/dev/null && [ $timeout -gt 0 ]; do
        sleep 1
        timeout=$((timeout - 1))
    done

    if kill -0 "$PID" 2>/dev/null; then
        echo "Force killing process..."
        kill -9 "$PID"
    fi

    rm -f "$PID_FILE"
    echo "Stopped"
}

status_process() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$PROCESS_NAME is running (PID: $PID)"
            return 0
        else
            echo "$PROCESS_NAME is not running (stale PID file)"
            return 1
        fi
    else
        echo "$PROCESS_NAME is not running"
        return 1
    fi
}

case "$ACTION" in
    start)
        start_process
        ;;
    stop)
        stop_process
        ;;
    restart)
        stop_process
        sleep 2
        start_process
        ;;
    status)
        status_process
        ;;
    *)
        echo "Usage: $0 <process-name> {start|stop|restart|status}"
        exit 1
        ;;
esac


============================================================

